
#include "likelihood_functions.h"

int UNIMPROVED_CUTOFF = 10; // cut off iterations for a component if it hasn't improved log likelihood in this many iterations

// flip hap1 and hap2 at v
void flip_haps(char* hap1, char* hap2, int v){
    if (hap1[v] == '1') hap1[v] = '0';
    else if(hap1[v] == '0') hap1[v] = '1';
    if (hap2[v] == '1') hap2[v] = '0';
    else if(hap2[v] == '0') hap2[v] = '1';
}

/**
 * @brief computes the likelihood of a fragment given one haplotype
 * 
 * @param hap an array representing a haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 *  * @return the (possibly partial) likelihood of the fragment given the haplotype (hap) and fragment quality scores
 */

float fragment_likelihood_h(char* hap, struct fragment* Flist, int f, int partial, char* S){
    
    int i, j, snp_ix;
    float q;
    float total = 1.0;
    // for each block in the fragment   
    for (i = 0; i < Flist[f].blocks; i++) {
        // for each allele in the block
        for (j = 0; j < Flist[f].list[i].len; j++) {
            
            snp_ix = Flist[f].list[i].offset + j;         // snp_ix is the 0-based index for this SNP's position
            
            // skip iteration if computing a partial likelihood and snp_ix not in the cut (S)
            if (partial && !S[snp_ix])
                continue;
            
            q = Flist[f].list[i].pv[j];                   // q is the probability of miscall at this position
            // if haplotype matches fragment, then multiply likelihood by probability call was correct
            if (Flist[f].list[i].hap[j] == hap[snp_ix]){
                total *= 1.0-q;
            }else{
            // if haplotype doesn't match fragment, then multiply likelihood by probability call was wrong
                total *= q;
            }
        }
    }
    /*
    if (total == 1.0){
        fprintf(stderr, "ERROR: Likelihood of fragment %d found to be 1. This should never happen.", f);
        exit(1);
    }
    */
    return total;
}

/**
 * @brief computes the log of the average likelihood of a fragment given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log base 10 of the mean of the likelihoods that the fragment was generated by each haplotype, given the fragment quality scores
 */

float fragment_loglikelihood_H(char* hap1, char* hap2, struct fragment* Flist, int f, int partial, char* S){
    float fragll = log10((fragment_likelihood_h(hap1, Flist, f, partial, S) + fragment_likelihood_h(hap2, Flist, f, partial, S))/2);
    //fprintf(stderr, "frag: %d fragll: %f\n", f, fragll);
    return fragll;
}

/**
 * @brief computes the log of the average likelihood of the dataset given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @param partial 0 (false) to compute likelihood of whole dataset. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector of length #SNPs to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float data_loglikelihood(char* hap1, char* hap2, struct fragment* Flist, int partial, char* S, int* frag_ix, int numfrags){
    int i;
    float total = 0;
    // iterate over every fragment
    for (i = 0; i < numfrags; i++){
        total += fragment_loglikelihood_H(hap1, hap2, Flist, frag_ix[i], partial, S);
    }
    //fprintf(stderr, "dataloglikelihood: %f\n", total);
    return total;
}

/**
 * @brief computes Lv, which is the difference in partial log likelihoods (limited only to the subset S)
 * between the case S1(union)v (v gets added to S1 and flipped) and the case S2(union)v (v gets added to S2; not flipped)
 * 
 * @param v the index of the vertex (a SNP column) being considered.
 * @param S the bit vector representing which vertices are in S=S1(union)S2
 * @param hap1 an array representing the first haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param hap2 an array representing the second haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float cut_difference_Lv(int v, char* S, char* hap1, char* hap2, struct fragment* Flist, struct BLOCK* clist, int k){
   
    float S_ll, S_union_v_ll, lv;    
    // if we're considering adding v to S, it shouldn't be in it already.
    assert(S[v]  == 0);
    // if homozygous at v, Lv will just be 0
    if (hap1[v] == hap2[v]){
        return 0;
    }
    
    S[v]  = 1;
    
    // compute partial likelihood when v is in S2 (doesn't get flipped in haps)
    S_ll = data_loglikelihood(hap1, hap2, Flist, 1, S, clist[k].flist, clist[k].frags);
    
    // temporarily flip the haplotypes at v and recompute
    flip_haps(hap2, hap2, v);
    
    // compute partial likelihood when v is in S1 (gets flipped in haplotypes)
    S_union_v_ll = data_loglikelihood(hap1, hap2, Flist, 1, S, clist[k].flist, clist[k].frags);
    
    // lv is the difference in the partial log_likelihoods of S1(union)v
    lv = S_ll - S_union_v_ll;

    // undo temporary changes; remove v from S and flip back haplotypes at v
    S[v]  = 0;
    flip_haps(hap1, hap2, v);
    
    return lv;
}

float compute_goodcut(struct SNPfrags* snpfrag, char* HAP1, char* HAP2, char* S, int* slist, int N, struct fragment* Flist, struct BLOCK* clist, int k){

    int i, j, node1, node2, max_j;
    float lv, max_lv, dll;
    
    int rand1 = drand48()*N;
    int rand2 = drand48()*N;

    node1 = slist[rand1];
    do{
        node2 = slist[rand2];
        rand2 = drand48()*N;
    }while(node2 == node1);
    
    S[node1] = 1;
    S[node2] = 1;

    flip_haps(HAP1, HAP2, node1);
    for (i = 0; i < N; i++){
        max_j = -1;
        max_lv = -1;
        for (j = 0; j < N; j++){
            if (S[slist[j]]){
                continue;
            }
            lv = cut_difference_Lv(slist[j], S, HAP1, HAP2, Flist, clist, k);
            if(abs(lv) > max_lv){
                max_lv = lv;
                max_j = j;
            }
        }
        S[slist[max_j]] = 1;
        if (max_lv < 0){
            // choose S1 union v
            flip_haps(HAP1, HAP2, slist[max_j]);
        }else if (max_lv > 0){
            // choose S2 union v
            // pass
        }else if (drand48() > 0.5){
            flip_haps(HAP1, HAP2, slist[max_j]);
        }
    }
    dll = data_loglikelihood(HAP1, HAP2, Flist, 0, 0, clist[k].flist, clist[k].frags);
    return dll;
}

int evaluate_cut_component(struct fragment* Flist, char* S, struct SNPfrags* snpfrag, struct BLOCK* clist, int k, char* HAP1, char* HAP2, int iter){
    int N = clist[k].phased;
     // if this component hasn't improved in 10 iterations then skip evaluation
 //   if (clist[k].iters_since_improvement >= UNIMPROVED_CUTOFF){
 //       return 1; // unlikely to improve
 //   }
   
    char* oldHAP1 = malloc(strlen(HAP1)*sizeof(char)); 
    char* oldHAP2 = malloc(strlen(HAP2)*sizeof(char));
    strcpy(oldHAP1, HAP1);
    strcpy(oldHAP2, HAP2);
    

    int* slist = clist[k].slist;
    // compute a 'max-cut' of columns
    clist[k].LL = compute_goodcut(snpfrag, HAP1, HAP2, S, slist, N, Flist, clist, k);
    if (k==5) fprintf(stderr, "ll: %f\n", clist[k].LL);
    if (clist[k].LL > clist[k].bestLL){
        // found a new best log likelihood
        clist[k].bestLL = clist[k].LL;
    }else{
        // haplotype wasn't improved
        // flip back haplotypes at members of S
        HAP1 = oldHAP1;
        HAP2 = oldHAP2;
        
        //clist[k].iters_since_improvement++;
        return 1;
    }
    
    return 0; // component was improved
}