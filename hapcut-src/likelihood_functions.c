
#include "fragmatrix.h"

// flip hap1 and hap2 at v
float fliphaps(char* hap1, char* hap2, int v){
    if (hap1[v] == '1') hap1[v] = '0';
    else if(hap1[v] == '0') hap1[v] = '1';
    if (hap2[v] == '1') hap2[v] = '0';
    else if(hap2[v] == '0') hap2[v] = '1';
}

/**
 * @brief computes the likelihood of a fragment given one haplotype
 * 
 * @param hap an array representing a haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 *  * @return the (possibly partial) likelihood of the fragment given the haplotype (hap) and fragment quality scores
 */

float fragment_likelihood_h(char* hap, struct fragment* Flist, int f, int partial, int* S){
    
    int i, j, snp_ix;
    float q;
    float total = 1.0;
    // for each block in the fragment   
    for (i = 0; i < Flist[f].blocks; i++) {
        // for each allele in the block
        for (j = 0; j < Flist[f].list[i].len; j++) {
            
            snp_ix = Flist[f].list[i].offset + j;         // snp_ix is the 0-based index for this SNP's position
            
            // skip iteration if computing a partial likelihood and snp_ix not in the cut (S)
            if (partial && !S[snp_ix])
                continue;
            
            q = Flist[f].list[i].pv[j];                   // q is the probability of miscall at this position
            // if haplotype matches fragment, then multiply likelihood by probability call was correct
            if (Flist[f].list[i].hap[j] == hap[snp_ix]){
                total *= 1.0-q;
            }else{
            // if haplotype doesn't match fragment, then multiply likelihood by probability call was wrong
                total *= q;
            }
        }
    }
    
    if (total == 1.0){
        fprintf(stderr, "ERROR: Likelihood of fragment %d found to be 1. This should never happen.", f);
        exit(1);
    }
    
    return total;
}

/**
 * @brief computes the log of the average likelihood of a fragment given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log base 10 of the mean of the likelihoods that the fragment was generated by each haplotype, given the fragment quality scores
 */

float fragment_loglikelihood_H(char* hap1, char* hap2, struct fragment* Flist, int f, int partial, int* S){
    return log10((fragment_likelihood_h(hap1, Flist, f, partial, S) + fragment_likelihood_h(hap2, Flist, f, partial, S))/2);
}

/**
 * @brief computes the log of the average likelihood of the dataset given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @param partial 0 (false) to compute likelihood of whole dataset. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector of length #SNPs to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float data_loglikelihood(char* hap1, char* hap2, struct fragment* Flist, int partial, int* S, int* frag_ix, int numfrags){
    int i, total = 0;
    // iterate over every fragment
    for (i = 0; i < numfrags; i++){
        total += fragment_loglikelihood_H(hap1, hap2, Flist, frag_ix[i], partial, S);
    }
    return total;
}

/**
 * @brief computes Lv, which is the difference in partial log likelihoods (limited only to the subset S)
 * between the case S1(union)v (v gets added to S1 and flipped) and the case S2(union)v (v gets added to S2; not flipped)
 * 
 * @param v the index of the vertex (a SNP column) being considered.
 * @param S the bit vector representing which vertices are in S=S1(union)S2
 * @param hap1 an array representing the first haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param hap2 an array representing the second haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float cut_difference_Lv(int v, int* S, char* hap1, char* hap2, struct fragment* Flist, int fragments, BLOCK* clist, int k){
   
    float S_ll, S_union_v_ll, lv;    
    // if we're considering adding v to S, it shouldn't be in it already.
    assert(S[v]  == 0);
    // if homozygous at v, Lv will just be 0
    if (hap1[v] == hap2[v]){
        return 0;
    }
    
    S[v]  = 1;
    
    // compute partial likelihood when v is in S2 (doesn't get flipped in haps)
    S_ll = data_loglikelihood(hap1, hap2, Flist, 1, S, clist[k].flist, clist[k].frags);
    
    // temporarily flip the haplotypes at v and recompute
    fliphaps(hap2, hap2, v)
    
    // compute partial likelihood when v is in S1 (gets flipped in haplotypes)
    S_union_v_ll = data_loglikelihood(hap1, hap2, Flist, 1, S, clist[k].flist, clist[k].frags)
    
    // lv is the difference in the partial log_likelihoods of S1(union)v
    lv = S_ll - S_union_v_ll

    // undo temporary changes; remove v from S and flip back haplotypes at v
    S[v]  = 0;
    fliphaps(hap1, hap2, v);
    
    return lv;
}