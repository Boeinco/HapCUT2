
#include "likelihood_functions.h"

int UNIMPROVED_CUTOFF = 10; // cut off iterations for a component if it hasn't improved log likelihood in this many iterations

// flip hap1 and hap2 at v
void flip_haps(char* hap1, char* hap2, int v){
    if (hap1[v] == '1') hap1[v] = '0';
    else if(hap1[v] == '0') hap1[v] = '1';
    if (hap2[v] == '1') hap2[v] = '0';
    else if(hap2[v] == '0') hap2[v] = '1';
}

/**
 * @brief computes the likelihood of a fragment given one haplotype
 * 
 * @param hap an array representing a haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 *  * @return the (possibly partial) likelihood of the fragment given the haplotype (hap) and fragment quality scores
 */

float fragment_likelihood_h(char* hap, struct fragment* Flist, int f, char* S1, int partial, char* S){
    
    int i, j, snp_ix, frag_ix = 0;
    float q;
    float total = 1.0;
    // for each block in the fragment   
    for (i = 0; i < Flist[f].blocks; i++) {
        // for each allele in the block
        for (j = 0; j < Flist[f].list[i].len; j++) {
            
            // skip iteration if computing a partial likelihood and snp_ix not in the cut (S)
            if (partial && !S[frag_ix])
                continue;
            
            snp_ix = Flist[f].list[i].offset + j;         // snp_ix is the 0-based index for this SNP's position
            
            q = Flist[f].list[i].pv[j];                   // q is the probability of miscall at this position
            
            // if haplotype matches fragment, then multiply likelihood by probability call was correct
            if ((Flist[f].list[i].hap[j] == hap[snp_ix] && !S1[frag_ix])||
               (Flist[f].list[i].hap[j] != hap[snp_ix] &&  S1[frag_ix])){
                total *= 1.0 - q;
            }else{
            // if haplotype doesn't match fragment, then multiply likelihood by probability call was wrong
                total *= q;
            }
            
            frag_ix++;
        }
    }
    /*
    if (total == 1.0){
        fprintf(stderr, "ERROR: Likelihood of fragment %d found to be 1. This should never happen.", f);
        exit(1);
    }
    */
    return total;
}

/**
 * @brief computes the log of the average likelihood of a fragment given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param f the index of the fragment under consideration
 * @param partial 0 (false) to compute likelihood of whole fragment. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log base 10 of the mean of the likelihoods that the fragment was generated by each haplotype, given the fragment quality scores
 */

float fragment_loglikelihood_H(char* hap1, char* hap2, struct fragment* Flist, int f, char* S1, int partial, char* S){
    float fragll = log10((fragment_likelihood_h(hap1, Flist, f, S1, partial, S) + fragment_likelihood_h(hap2, Flist, f, S1, partial, S))/2);
    //fprintf(stderr, "frag: %d fragll: %f\n", f, fragll);
    return fragll;
}

/**
 * @brief computes the log of the average likelihood of the dataset given two possible haplotypes
 * 
 * @param hap1 an array representing the first haplotype
 * @param hap2 an array representing the second haplotype
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @param partial 0 (false) to compute likelihood of whole dataset. 1 (true) to compute partial likelihood using only columns specified by bit vector S
 * @param S only necessary if partial is set to 1 (else can be null). a bit vector of length #SNPs to specify a 'cut' of the SNP columns. 1: column is in S. 0: column is not in S. 
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float data_loglikelihood(char* hap1, char* hap2, struct fragment* Flist, char* S1, int partial, char* S, int* frag_ix, int numfrags){
    int i;
    float total = 0;
    // iterate over every fragment
    for (i = 0; i < numfrags; i++){
        total += fragment_loglikelihood_H(hap1, hap2, Flist, frag_ix[i], S1, partial, S);
    }
    //fprintf(stderr, "dataloglikelihood: %f\n", total);
    return total;
}

/**
 * @brief computes Lv, which is the difference in partial log likelihoods (limited only to the subset S)
 * between the case S1(union)v (v gets added to S1 and flipped) and the case S2(union)v (v gets added to S2; not flipped)
 * 
 * @param v the index of the vertex (a SNP column) being considered.
 * @param S the bit vector representing which vertices are in S=S1(union)S2
 * @param hap1 an array representing the first haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param hap2 an array representing the second haplotype. The indices in S1 should ALREADY BE FLIPPED BY NOW.
 * @param Flist an array of pointers to fragment structs (represents the list of fragments)
 * @param fragments the number of fragments in Flist
 * @return the log likelihood of the data given the haplotypes (more correctly, the log likelihood of the isolated fragment block under consideration)
 */

float cut_difference_Lv(int v, char* S1, char* S, char* hap1, char* hap2, struct fragment* Flist, struct BLOCK* clist, int k){
   
    float S_ll, S_union_v_ll, lv;    
    // if we're considering adding v to S, it shouldn't be in it already.
    assert(S[v]  == 0);
    // if homozygous at v, Lv will just be 0
    if (hap1[v] == hap2[v]){
        return 0;
    }
    
    S[v]  = 1;
    
    // compute partial likelihood when v is in S2 (doesn't get flipped in haps)
    S_ll = data_loglikelihood(hap1, hap2, Flist, S1, 1, S, clist[k].flist, clist[k].frags);
    
    // temporarily add v to S1 and recompute
    S1[v] = 1;

    // compute partial likelihood when v is in S1 (gets flipped in haplotypes)
    S_union_v_ll = data_loglikelihood(hap1, hap2, Flist, S1, 1, S, clist[k].flist, clist[k].frags);
    
    // lv is the difference in the partial log_likelihoods of S1(union)v
    lv = S_ll - S_union_v_ll;

    // undo temporary changes; remove v from S and flip back haplotypes at v
    S[v]  = 0;
    S1[v] = 0;
    
    return lv;
}

float compute_goodcut(struct SNPfrags* snpfrag, char* HAP1, char* HAP2, char* S1, char* S, int* slist, int N, struct fragment* Flist, struct BLOCK* clist, int k){

    int i, j, n1, n2, max_j;
    float lv, max_lv, dll;
    
    n1 = drand48()*N;
    n2 = drand48()*N;

    do{
        n2 = drand48()*N;
    }while(n2 == n1);
    
    S1[n1] = 1;
    S[n1] = 1;
    S[n2] = 1;

    for (i = 0; i < N; i++){
        max_j = -1;
        max_lv = -1;
        for (j = 0; j < N; j++){
            if (S[j]){
                continue;
            }
            lv = cut_difference_Lv(j, S1, S, HAP1, HAP2, Flist, clist, k);
            if(abs(lv) > max_lv){
                max_lv = abs(lv);
                max_j = j;
            }
        }
        assert(max_j != -1);
        S[max_j] = 1;
        if (max_lv < 0){
            // choose S1 union v
            S1[max_j] = 1;
        }else if (max_lv > 0){
            // choose S2 union v
            // pass
        }else if (drand48() > 0.5){
            S1[max_j] = 1;
        }
    }
    dll = data_loglikelihood(HAP1, HAP2, Flist, S1, 0, 0, clist[k].flist, clist[k].frags);
    return dll;
}

int evaluate_cut_component(struct fragment* Flist, struct SNPfrags* snpfrag, struct BLOCK* clist, int k, char* HAP1, char* HAP2, int iter){
    int i, N = clist[k].phased;
     // if this component hasn't improved in 10 iterations then skip evaluation
 //   if (clist[k].iters_since_improvement >= UNIMPROVED_CUTOFF){
 //       return 1; // unlikely to improve
 //   }
   
    char* S  = (char*) calloc(N, sizeof(char));
    char* S1 = (char*) calloc(N, sizeof(char));

    // compute a 'max-cut' of columns
    clist[k].LL = compute_goodcut(snpfrag, HAP1, HAP2, S1, S, clist[k].slist, N, Flist, clist, k);

    if (clist[k].LL > clist[k].bestLL){
        // found a new best log likelihood
        clist[k].bestLL = clist[k].LL;
        for (i = 0; i < N; i++){
            if (S1[i]){
                flip_haps(HAP1, HAP2, clist[k].slist[i]);
            }
        }
    }else{
        // haplotype wasn't improved        
        //clist[k].iters_since_improvement++;
        free(S);
        free(S1);
        return 1;
    }
    
    free(S);
    free(S1);
    
    return 0; // component was improved
}